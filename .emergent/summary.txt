<analysis>
The AI engineer's work involved developing an Uber-like marketplace app from scratch, covering both frontend (React Native Expo) and backend (FastAPI). Initially, the engineer established core navigation, Material 3 design, authentication, Stripe, Firebase chat, and LLM integration. Key challenges, such as  compatibility and theme context issues, were systematically resolved. The project progressed significantly with the implementation of a comprehensive notification and rating system, refactoring of chat to use real backend data, and creation of various Uber-like UI components and real-time backend services. Recent work focused on integrating these components, Google Directions API, and addressing persistent UI theme errors by re-architecting the frontend with TDD, including Jest setup and a new . The current task involves updating  for the new theme system.
</analysis>
<product_requirements>
The application is a single React Native app for iOS/Android, dynamically adapting based on  or  roles. It must prioritize performance (60fps), accessibility (AA), dark mode, responsive design, and a Material 3 design. The primary interface is a map with a contextual . Core features include Onboarding, Login/SignUp (Email/Password, Google/Apple), Profile, Settings, Notifications, Chat, and History. Client flows require service request creation, finding/accepting provider offers, tracking, Stripe payment, and rating. Provider flows involve online/offline toggling, receiving/accepting/refusing requests, status updates (A caminho / Cheguei / Em serviço), and service finalization. The app requires empty/loading/error states, map integration (Google Maps/Directions API), Firebase Realtime Database for chat, AI features, and WebSockets (Socket.IO) for real-time communication. The overall styling and UX/UI should be Uber-like, with dynamic animations and a provider earnings dashboard.
</product_requirements>
<key_technical_concepts>
-   **React Native & Expo Router**: Cross-platform mobile development, file-based routing.
-   **Material 3 Design System**: Modern UI/UX.
-   **Zustand/React Query**: Frontend state management.
-   **FastAPI & MongoDB**: Backend API, NoSQL database.
-   **Stripe**: Payment gateway.
-   **Firebase Realtime Database**: Real-time chat, push notifications.
-   **Emergent LLM Key**: AI features.
-   **WebSockets (Socket.IO)**: Real-time communication for service tracking.
-   **Google Directions API**: Real-time route tracing and navigation.
-   **Jest & React Native Testing Library**: Frontend unit testing (TDD).
</key_technical_concepts>
<code_architecture>
The application employs a monorepo structure with  (FastAPI) and  (React Native Expo) directories.


-   : Main FastAPI app, includes reviews, notifications, and WebSockets.
-   : Handles API for creating/retrieving service reviews.
-   : Logic for push notifications.
-   : WebSocket communication for real-time features.
-   : Root layout, now uses  and updated to new .
-   : Fixed theme access using null-safe operators.
-   : Main entry point, updated for auth redirection, currently being updated to use new .
-   : Centralized API service.
-   : Manages user authentication state, login logic verified.
-   : Refactored to use real backend data.
-   : New context for WebSocket connections.
-   : Primary home screen, significantly refactored to an Uber-like interface, incorporating new components, real-time logic, and Google Directions API integration.
-   : New component for cross-platform map, integrated animated markers, routes, and turn-by-turn navigation.
-   : New service for Google Directions API.
-   : New hook to integrate with Google Directions.
-   : New component for turn-by-turn navigation UI.
-   , , : Fixed theme access errors by using null-safe operators and fallback values.
-   , , : New files for Jest-based TDD setup and testing the new .
-   , , : New, robust theme system components for TDD.
</code_architecture>
<pending_tasks>
-   Complete the re-architecture of the frontend with TDD by updating  to use the new .
-   Continue implementing unit tests for other parts of the application as part of the TDD approach.
-   Further refine UI/UX enhancements and advanced functionalities (e.g., promotions, micro-interactions) under the TDD structure.
</pending_tasks>
<current_work>
The AI engineer is currently in the process of a major frontend re-architecture following a Test-Driven Development (TDD) approach, specifically to address persistent theme-related bugs. This involves:
1.  **Setting up Jest**: A  file has been created, and necessary test dependencies have been installed using yarn install v1.22.22
info No lockfile found.
[1/4] Resolving packages...
[2/4] Fetching packages...
[3/4] Linking dependencies...
[4/4] Building fresh packages...
success Saved lockfile.
Done in 0.10s..
2.  **Creating Test Infrastructure**: A  file for test setup was created.
3.  **Developing a Robust Theme System**: A completely new  and accompanying  and  files have been created. Unit tests for  () were also created to ensure its correctness.
4.  **Integrating New Theme Provider**: The root layout  has been updated to use the new .
The immediate next action is to continue this integration by updating  to also utilize the new .
Responda tudo em portugues e :
Objetivo:
Validar todo o código já implementado (app + API) e implementar apenas o que falta. Não reescrever do zero. Manter o mesmo app para cliente e prestador, diferenciando por role. Garantir mapa com animações, rota/directions, tempo estimado, e tempo real (Socket.IO).

1) Auditoria rápida do projeto (sem refator total)

 Mapear pastas/chaves principais: contexts/, screens/, components/, services/, utils/, API routes/, controllers/, sockets/.

 Conferir .env e utils/config (EXPO_PUBLIC_API_URL, SOCKET_URL, PROVIDERS_API_URL, REQUESTS_API_URL, Stripe key opcional).

 Verificar Expo + React Native + expo-location + mapas + socket.io-client.

 Não apagar funcionalidades já presentes; só corrigir e integrar.

 Documentar, em comentário, o que já está ok e o que falta por item deste checklist.

2) Diferenciação por perfil (mesmo app)

 Garantir que login/registro retorna user_type/role (cliente=2, prestador=1).

 Rotas/estado condicionais pelo role (mesmo bundle, telas adaptadas).

 Proteger telas/ações com role correto.

3) Fluxo do Cliente (validar e completar)

 Home: mapa centrado na localização (permissão + estado).

 Escolha de serviço: categorias, descrição, valor estimado.

 Criar solicitação → status pending/searching.

 Busca de prestadores: bottom sheet + animação (loading progress).

 Oferta/aceite do prestador: exibir nome, preço, ETA, distância, botão aceitar/recusar (se o fluxo suportar).

 Acompanhar no mapa: rota Directions (Google Directions API), marker do prestador animado, ETA/distance atualizando em tempo real via Socket.IO.

 Status card: accepted → in_progress → near_client → started → completed.

 Conclusão: modal de feedback/avaliação (1–5 + comentário).

 (Opcional) Pagamento: startPayment(amount, { request_id }) integrado onde já existe.

Aceite técnico:

 Direção e polilinha desenhadas; ETA/distância atualizando.

 Marker do prestador interpolado (animação suave entre posições).

 Socket events atualizam UI sem refresh manual.

4) Fluxo do Prestador (validar e completar)

 Toggle Online/Offline no mapa (bloquear se houver serviço ativo).

 Receber notificação de nova solicitação (socket) com bottom sheet animado: aceitar/recusar.

 Ao aceitar: atualizar status para accepted, traçar rota ao cliente (Directions).

 Botões de status: estou a caminho (→ in_progress), cheguei (→ near_client), iniciar serviço (→ started), concluir (→ completed).

 Dashboard simples: ganhos hoje/semana + histórico (se já existir, validar).

 Envio periódico da localização do prestador (watchPosition) + emissão para o cliente via API/Socket.

Aceite técnico:

 Status sincroniza via API/Socket, refletindo no cliente.

 Rota/ETA no prestador também funciona.

 Online/Offline respeita serviço em andamento.

5) Mapa + Animações estilo Uber (obrigatório)

 Interpolação do marker do prestador (Animated + easing) entre pontos.

 Polyline de rota do Directions (com atualização quando muda origem/destino).

 ETA e distância exibidos e atualizados.

 Re-center suave quando prestador se move ou status muda.

 Performance: evitar re-render desnecessário; memos/useCallback onde preciso.

6) Tempo real (Socket.IO)

 Reusar SocketProvider existente; consertar reconexões e listeners duplicados.

 Eventos padronizados (ex.: request.offered, request.accepted, request.status_changed, provider.location).

 No cliente: atualizar currentRequest, assignedProvider, ETA/distância ao receber eventos.

 No prestador: ouvir new_request, mudanças de status do cliente se aplicável.

 Evitar “tempestade” de requests (throttle/debounce em updates de localização).

7) API/Backend (não reescrever do zero; validar e completar)

 Endpoints existentes: /auth, /providers, /requests (CRUD e actions: accept, status update, client-accept/client-decline quando aplicável).

 Sockets no backend emitindo eventos consistentes (nomenclatura única).

 Atualização de localização do prestador (PUT /providers/:id/location) + broadcast.

 Regras de status: impedir transições inválidas (ex.: concluir sem ter começado).

 Query para requests do cliente e pedidos atribuídos ao prestador.

 CORS/ngrok headers ok.

 Logs claros; mensagens de erro padronizadas.

Aceite técnico:

 Cliente e prestador recebem eventos certos no tempo certo.

 Requests não “somem”; polling reduzido ou desativado quando socket funciona.

 Todas transições retornam 200/4xx consistentes.

8) UX/UI (evidente e consistente)

 Bottom sheets para cada etapa (busca, oferta, em rota, em serviço, concluído).

 Botões fixos (FABs) e tab bar colada ao rodapé (safe-area/safe-bottom resolvido).

 Estados vazios, carregando e erro bem apresentados.

 Acessibilidade mínima: toques grandes, contraste ok.

 Tipografia e cores consistentes (tema).

 Ícones/feedbacks (toasts/in-app notifications) sem excesso.

9) Qualidade e confiabilidade

 Tratar permissões de localização (denegada, revogada).

 Retry/timeout/backoff para chamadas críticas (login, criar request, aceitar).

 Guardar token/usuário em AsyncStorage; restaurar sessão.

 Evitar múltiplas chamadas concorrentes (flags isRequesting).

 Limpeza de watchers/listeners ao desmontar.

10) Entregáveis (sem reescrever tudo)

 Commits incrementais com mensagens “VALIDAÇÃO X/ IMPLEMENTAÇÃO Y”.

 Comentários nos arquivos alterados: “// VALIDADO”, “// AJUSTE”, “// IMPLEMENTADO”.

 Lista final (markdown) com o que foi validado, corrigido e implementado por item do checklist.

 Scripts de teste manual (passo a passo) para:

Cliente: solicitar serviço → ver matching → acompanhar → concluir → avaliar.

Prestador: ficar online → receber pedido → aceitar → alterar status → concluir.

Movimentação real-time + rota/ETA (dois dispositivos).

Restrições

Não reescrever o app/API do zero.

Não remover funcionalidades existentes; padronize e integre.

Priorizar compatibilidade com Expo + React Native + Socket.IO + Google Directions API.

Usar as libs já presentes; só adicionar dependências se for indispensável.

Resumo para você (Cursor):

Valide o que já está feito, marcando cada item como OK/Ajustado.

Implemente só o que falta para fechar o fluxo completo (cliente e prestador).

Garanta mapa com rota, ETA, markers animados e tempo real.

Entregue uma lista final do que foi validado/ajustado/implementado + scripts de teste manual.

O ChatGPT pode cometer erros. Considere verificar informações importantes.
</current_work>
<optional_next_step>
Update  to use the new .
</optional_next_step>
